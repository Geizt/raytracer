// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ({
    rt: (typeof exports !== "undefined" && exports !== null) && exports || this.rt || (this.rt = {})
  });

  rt.Sphere = (function(_super) {

    __extends(Sphere, _super);

    function Sphere(center, radius, surface) {
      if ((center != null) && (radius != null) && (surface != null)) {
        if (!(typeof center.IsValid === "function" ? center.IsValid() : void 0) || !rt.MathLibrary.IsValid(radius) || !(typeof surface.IsValid === "function" ? surface.IsValid() : void 0)) {
          throw new TypeError;
        }
      } else {
        throw new TypeError;
      }
      this.center = center;
      this.radius_squared = radius * radius;
      this.surface = surface;
    }

    Sphere.prototype.IsValid = function() {
      return this.center.IsValid() && rt.MathLibrary.IsValid(this.radius_squared) && this.surface.IsValid();
    };

    Sphere.prototype.Normal = function(position) {
      if (!(position != null) || !position.IsValid()) {
        throw new TypeError;
      }
      return rt.MathLibrary.VectorSubtraction(position, this.center).Normalize();
    };

    Sphere.prototype.Intersect = function(ray) {
      var direction, disc, distance, projection;
      if (!(ray != null) || !ray.IsValid()) {
        throw new TypeError;
      }
      direction = rt.MathLibrary.VectorSubtraction(this.center, ray.origin);
      projection = direction.Dot(ray.direction);
      distance = 0;
      if (projection >= 0) {
        disc = this.radius_squared - (direction.Dot(direction) - (projection * projection));
        if (disc >= 0) {
          distance = projection - Math.sqrt(disc);
        }
      }
      if (distance === 0) {
        return null;
      } else {
        return new rt.Intersection(this, ray, distance);
      }
    };

    return Sphere;

  })(rt.GeometricObject);

}).call(this);
